# 러스트 고급 기능

- Unsafe Rust: 러스트의 손을 떠나 수동으로 안전을 보장하기
- 고급 라이프타임
- 고급 트레잇: 연관 타입, 기본 타입 파리미터, 완전 정규화 문법, 슈퍼트레잇, ..
- 고급 타입: 신종 타입 패턴, 타입 별칭, `never` 타입, 동적 크기 조절 타입
- 고급 함수 및 클로저: 함수 포인터와 클로저 반환하기

# 안전하지 않은 러스트

컴파일 타임에 강제되는 메모리 안전성을 해제하고 코드를 작성할 수 있다.

## 안전하지 않은 슈퍼파워

안전하지 않은 코드를 작성하기 위해 `unsafe` 키워드를 사용한다.

안전하지 않은 러스트는 아래 4가지 행동이 가능하다.

- 로우 포인터 역참조하기
- 안전하지 않은 함수나 메서드 호출하기
- 가변 정적 변수 접근과 수정하기
- 안전하지 않은 트레잇 구현하기

`unsafe` 내의 코드가 무저건 위험한 것은 아니다.

`unsafe`는 그 안의 코드가 올바른 방법으로 메모리에 접근하겠다는 것을 명시하는 것이다.

안전하지 않은 코드를 안전한 API로 추상화할 수 도 있다.

## 로우 포인터 역참조하기

로우 포인터는 참조자 처럼 불변이나 가변 타입을 가진다.

불변은 `*const T`로 가변은 `*mut T`라고 쓴다.

여기서 애스터리스크 `*`는 역참조가 아니라 타입명의 일부다.

로우 포인터의 *불변*은 포인터가 역참조된 후에 직접 대입될 수 없음을 의미한다.

## 로우포인터의 성질

- 로우 포인터는 빌림 규칙을 무시할 수 있어서 포인터가 불변과 가변 성질을 다 갖거나 다수의 가변 포인터가 존재할 수 있다.
- 로우 포인터가 가리키는 메모리가 유효한 지 알 수 없다.
- 널이 될 수 있다.
- 메모리 정리가 자동으로 되지 않는다.

안정성을 포기하고 성능을 향상시키거나 다른 언어나 하드웨어와 상호작용을 할 수 있다.

아래 코드는 참조자에서 불변, 가변 로우 포인터를 만든다.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

위 코드는 유효한 참조자에서 로우 포인터를 만들어서, 로우 포인터가 유효함을 알 수 있다.

반면, 다음과 같이 임의의 위치를 가리켜서 유효한 지 알 수 없는 로우 포인터를 만들 수 있다.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

안전한 코드 내에서는 로우 포인터 생성은 가능해도, 로우 포인터를 역참조해서 해당 포인터가 가리키는 데이터는 읽을 수 없다.

다음 코드는 `unsafe` 블록 내에서 로우 포인터의 값을 사용한다.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

위 코드는 동일한 메모리를 가리키는 로우 포인터 2개를 생성했다.

가변 포인터로 데이터 변경이 가능하기 때문에 데이터 레이스가 발생할 여지가 있다.

## 안전하지 않은 함수 혹은 메소드 호출하기

## 안전하지 않은 코드 상에 안전한 추상화 생성하기

## extern 함수를 사용하여 외부 코드 호출하기

## 가변 정적 변수의 접근 혹은 수정하기

## 안전하지 않은 트레잇 구현하기

## 언제 안전하지 않은 코드를 이용할까요?
