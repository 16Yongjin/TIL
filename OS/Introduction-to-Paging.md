# 페이징 개론

운영 체제에서 메모리 관리를 할 때 흔히 사용되는 *페이징*을 알아본다. 메모리 분리가 필요한 이유와 세그먼테이션의 작동 방식, 가상 메모리, 페이징이 메모리 단편화 문제를 해결하는 방법을 다룰 것이다. 또한, x86_64 아키텍처에서 사용하는 페이지 테이블의 다층 구조도 살펴본다.

## 메모리 보호

프로그램 간 분리는 운영 체제 반드시 해야하는 일이다. 예를 들어, 웹 브라우저가 텍스트 에디터를 간섭하는 일이 없어야 한다. 이를 위해 운영 체제는 하드웨어 기능을 사용해서 프로세스가 소유한 메모리 구역을 다른 프로세스가 접근하지 못하게 한다. 하드웨어나 운영 체제 구현에 따라 프로그램 분리하는 방법이 다양하다.

예를 들어, 임베디드 시스템에 사용되는 ARM Cortex-M 프로세서는 [메모리 보호 장치](https://developer.arm.com/docs/ddi0337/e/memory-protection-unit/about-the-mpu) (Memory Protection Unit, MPU)가 있어서 메모리 구역에 다른 접근 권한(ex, 접근 불가, 읽기 전용, 읽고 쓰기 가능)을 갖도록 작은 숫자(ex, 8)를 지정할 수 있다. 메모리에 접근할 때마다 MPU가 메모리 구역 안에 있는 주소를 올바른 접근 권한으로 사용했는지 확인하고, 그렇지 않은 경우 예외를 발생시킨다. 프로세스를 전환할 때마다 구역과 접근 권한을 바꿔서 운영 체제가 각 프로세스가 자신의 메모리에 접근하도록 한다. 이런 식으로 프로세스를 서로 분리한다.

x86은 [세그먼테이션](https://ko.wikipedia.org/wiki/X86_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B6%84%ED%95%A0)과 [페이징](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95), 이 두 가지 메모리 보호 방식을 지원한다.

## 세그먼테이션 (메모리 분할)

세그먼테이션은 접근할 수 있는 메모리 양을 늘리기 위해 1978년에 도입됐다. 그 당시에 CPU는 16비트 주소만 사용할 수 있어서 접근할 수 있는 메모리 양이 64KB로 제한됐다. 64KB보다 더 많이 접근하기 위해 세그먼트 레지스터들이 추가됐고, 각 세그먼트 레지스터는 오프셋 주소를 담는다. CPU는 메모리에 접근할 때마다 오프셋을 더 해서, 1MB 크기의 메모리까지 접근이 가능했다.

CPU는 메모리 접근 방식에 따라 세그먼트 레지스터를 자동으로 선택한다. 명령어를 가져올 땐 코드 세그먼트(`CS`)를 사용하고, 스택 연산(push/pop) 시 스택 세그먼트(`SS`)를 사용한다. 다른 명령어는 데이터 세그먼트(`DS`)나 여분 세그먼트(`ES`)를 사용한다. 나중에 추가된 여분 세그먼트 레지스터인 `FS`와 `GS`는 자유롭게 사용된다.

세그먼테이션의 초창기 버전에서 오프셋이 세그먼트 레지스터에 그대로 담겨있었고 접근 제어도 실행되지 않았다. 초창기 버전은 [_보호 모드_](https://ko.wikipedia.org/wiki/%EB%B3%B4%ED%98%B8_%EB%AA%A8%EB%93%9C)가 도입되면서 변경됐다. CPU가 보호 모드에서 작동할 때, 세그먼트 디스크립터는 로컬과 글로벌 [_디스크립터 테이블_](https://en.wikipedia.org/wiki/Global_Descriptor_Table)의 인덱스를 담는다. 디스크립터 테이블은 오프셋 주소를 포함하여 세그먼트 사이즈와 접근 권한을 담는다. 각 프로세스 마다 프로세스 고유의 메모리 영역에만 접근하도록 하는 별개의 글로벌/로컬 디스크립터 테이블을 불러와서 운영 체제가 프로세스 간 분리를 할 수 있다.

실제 메모리 접근 전에 주소를 변경하는 방법을 사용하는 세그먼테이션은 현재 거의 모든 곳에서 사용 중인 _가상 메모리_ 기법을 이미 사용하고 있다.

### 가상 메모리

가상 메모리 개념은 물리적 저장 장치에서 메모리 주소를 추상화하는 것이다. 저장 장치에 직접 접근하지 않고 번역 단계를 먼저 거친다. 세그먼테이션에서는 현재 사용 중인 세그먼트의 오프셋 주소를 더하는 번역 단계를 거쳤다. 예를 들어, 프로그램이 오프셋이 `0x1111000`인 세그먼트의 메모리 주소 `0x1234000`를 접근하면 실제로는 둘을 더한 `0x2345000`에 접근한다.

번역하기 전의 주소를 _가상 주소_, 번역 후의 주소를 *물리 주소*로 구분할 수 있다. 물리 주소가 유일무이하고 항상 똑같이 구별되는 메모리 주소를 가리키는 것이 두 주소의 큰 차이점이다. 반면, 가상 주소는 번역 함수에 따라 값이 달라진다. 가상 주소가 같아도 서로 다른 물리 주소를 가리킬 수도 있다. 또한, 번역 함수가 다르면 같은 물리 주소인데 서로 다른 물리 주소를 가리킬 수도 있다.

같은 프로그램 두 개를 동시에 돌릴 때 이런 특성이 유용하게 쓰인다.

![virtual-memory](https://user-images.githubusercontent.com/22253556/81063454-c7a6c480-8f12-11ea-8e7a-c9fe6993172a.png)

위 그림에서 같은 프로그램 두 개가 서로 다른 번역 함수를 가지고 작동 중이다. 첫 번째 인스턴스는 세그먼트 오프셋이 100이므로 0-150 사이 가상 주소는 100-250 사이 실제 주소로 번역된다. 두 번째 인스턴스는 오프셋이 300이므로 0-150사이 가상 주소는 300-450 사이 실제 주소로 번역된다. 가상 메모리 기법은 두 프로그램이 같은 코드와 같은 가상 주소를 사용하면서 서로 간섭이 없도록 한다.

두 프로그램이 완전히 다른 가상 주소를 사용해도 실제 메모리의 아무 위치에나 프로그램을 놓을 수도 있다. 이 덕분에, 운영 체제는 프로그램을 다시 컴파일하지 않아도 가용 메모리를 모두 사용할 수 있다.

### 파편화

가상 주소와 물리 주소를 다르게 두는 것이 세그먼테이션의 강력한 기능이지만, 파편화 문제도 뒤따른다.

![fragmetation]](https://user-images.githubusercontent.com/22253556/81064384-9202db00-8f14-11ea-98ff-90b0e2a0d2cb.png)

위 그림을 보면, 충분한 공간이 있어도 프로그램의 세 번째 인스턴스를 가상 메모리에 겹치지 않게 놓을 방법이 없다. 메모리가 연속되어 있어야 하는 것과 비어있는 작은 메모리 공간을 사용할 수 없는 것이 문제다.

파편화를 해결하기 위해, 실행을 멈추고, 사용 중인 메모리끼리 붙여놓고, 오프셋을 변경하고 다시 실행하는 방법이 있다.

![brute-force-fragmetation-solution](https://user-images.githubusercontent.com/22253556/81065191-fc684b00-8f15-11ea-9f59-7653bf8b414b.png)

이제 연속된 공간이 충분히 있어서 세 번째 인스턴스를 실행할 수 있다.

이런 식의 조각 모음은 대용량의 메모리를 복사하므로 성능이 떨어진다. 또한, 파편화가 심해지기 전에 정기적으로 수행되야 하므로 프로그램이 무작위로 멈춰서 성능 예측이 힘들어지고 운영 체제의 반응이 멈출 수도 있다.

파편화 문제 때문에 대부분의 시스템에서 세그먼테이션을 사용하지 않는다. 정확히는, x86의 64비트 모드가 세그먼테이션을 지원하지 않는다. 대신에 파편화 문제를 완전히 피할 수 있는 _페이징_ 기법을 사용한다.

## 페이징

페이징은 가상 메모리와 물리 메모리 공간을 고정 크기의 작은 블록으로 나눈다. 가상 메모리 공간의 블록은 *페이지*라고 하고 물리 주소 공간의 블록은 *프레임*이라고 한다. 각 페이지를 프레임에 하나씩 매핑할 수 있어서 대량의 메모리를 연속되어 있지 않은 물리 프레임에 나눠서 놓을 수 있다.

페이징을 사용하면 메모리 공간이 파편화되지 않는다.

![paging](https://user-images.githubusercontent.com/22253556/81172970-36028a00-8fda-11ea-9ef6-af1318ea370e.png)

위 그림에서 메모리 구역이 페이지 사이즈가 50 바이트인 페이지 3개로 나눠졌다. 각 페이지는 개별적으로 프레임에 매핑됐다. 덕분에 연속된 가상 메모리 공간을 연속되지 않은 물리 프레임에 매핑할 수 있게 됐다. 페이징을 사용하면 조각 모음을 하지 않아도 프로그램 인스턴스 세 개를 실행할 수 있다.

### 숨은 파편화

세그먼테이션은 소수의 크기가 크고 가변인 메모리 공간을 사용하지만, 페이징은 다수의 크기가 작고 고정된 메모리 공간을 사용한다. 모든 프레임의 크기가 같아서, 크기가 작다고 프레임을 사용 못 하는 경우가 없다. 그래서 파편화가 발생하지 않는다.

혹은, 파편화가 없는 것처럼 보이는 것일 수도 있다. 여전히 숨은 파편화가 존재하고, 이를 *내부 파편화*라고 한다. 메모리 공간이 모두 페이지 크키에 딱 맞게 나눠지지 않아서 내부 파편화가 발생한다. 페이지 크기가 50 바이트이면 크기가 101 바이트인 프로그램은 페이지 3개를 사용하고 49 바이트를 낭비한다. 한편, 세그먼테이션 사용 시 발생하는 파편화는 *외부 파편화*라고 한다.

내부 파편화는 나쁘지만, 세그먼테이션으로 발생하는 외부 파편화보단 낫다. 내부 파편화가 메모리를 낭비하긴 해도 조각 모음이 필요없고 파편화 발생량(메모리 영역 당 평균 페이지 절반 정도)을 예측할 수 있다.

### 페이지 테이블

페이지가 백만개 있다면 백만개 각각 프레임에 매핑돼야 한다. 이때 사용하는 매핑 정보는 어딘가에 보관해야 한다. 세그먼테이션은 활성 메모리 영역마다 별도의 세그먼트 선택자 레지스터를 사용했다. 페이징을 사용할 때는 페이지가 레지스터보다 훨씬 많으므로 별도의 레지스터를 사용할 수 없다. 대신에 테이블 구조의 *페이지 테이블*을 사용해서 매핑 정보를 보관한다.

위의 예시의 패이지 테이블은 다음과 같이 생겼다.

![page-table](https://user-images.githubusercontent.com/22253556/81176329-fc348200-8fdf-11ea-885a-2adf1f3d85de.png)

프로그램은 각자의 페이지 테이블을 갖는다. `x86` CPU는 현재 사용중인 테이블을 `CR3` 레지스터에 저장한다. 운영 체제는 프로그램을 실행하기 전에 알맞은 페이지 테이블을 가리키는 포인터를 `CR3` 레지스터에 저장해야 한다.

메모리에 접근할 때마다, CPU는 이 레지스터에서 테이블 포인터를 읽어와서 접근하려는 페이지에 매핑된 프레임을 테이블에서 찾는다. 이 과정은 하드웨어적으로 실행되고 실행 중인 프로그램에 완전히 투명하다. 많은 CPU 아키텍처는 번역 속도를 높이기 위해, 마지막 번역 결과를 기억하는 특수한 캐시를 갖고 있다.

아키텍처마다 다르지만, 페이지 테이블에 플래그 필드를 둬서 접근 권한 같은 속성을 저장하기도 한다. 위의 그림에서 "r/w" 플래그는 페이지를 읽고 쓸 수 있게 만든다.

### 다층 페이지 테이블

1단짜리 페이지 테이블은 메모리가 커지면 테이블도 커져서 메모리를 낭비하는 문제가 생긴다. 예를 들어, 프로그램이 가상 페이지 `0`, `1,000,000`, `1,000,050`, `1,000,100`번을 사용한다고 쳐보자.

![multilevel-page-table](https://user-images.githubusercontent.com/22253556/81292552-c1e1e800-90a6-11ea-8cfb-b05506cc77c2.png)

프로그램은 물리 페이지를 4개만 사용하지만, 페이지 테이블은 백만개가 넘는 항목을 갖게 된다. 그렇다고 빈 항목을 테이블에서 뺄 수 없다. 그럴 경우 CPU가 페이지를 번역할 때 알맞은 항목으로 바로 접근할 수 없기 때문이다. (네 번째 페이지가 네 번째 항목을 사용하는지 보장 못 함)

2단 페이지 테이블을 사용해서 메모리 낭비를 줄일 수 있다. 2단 테이블은 주소 구역이 다르면 다른 페이지 테이블을 사용하는 것이다. 레벨 2라는 테이블을 추가해서 주소 구역과 레벨 1 페이지 테이블 간의 매핑을 보관한다.

예를 들어, 레벨 1 페이지 테이블은 크기가 `10,000`인 구역만 담당하게 한다.

![2-level-page-table](https://user-images.githubusercontent.com/22253556/81294202-81379e00-90a9-11ea-811c-cb5baf933e90.png)

페이지 0은 첫 `10,000` 바이트 구역에 해당하므로 레벨 2 페이지 테이블의 첫 번째 항목을 사용한다. 이 항목은 레빌 1 페이지 테이블 T1을 가리킨다. T1은 페이지 0이 프레임 0을 가리키고 있음을 알려준다.

페이지 `1,000,000`, `1,000,050`, `1,000,100`는 100번째 `10,000` 바이트 구역에 해당하므로 레벨 2 페이지의 100번째 항목을 사용한다.
