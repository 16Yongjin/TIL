# 페이징 개론

운영 체제에서 메모리 관리를 할 때 흔히 사용되는 *페이징*을 알아본다. 메모리 분리가 필요한 이유와 세그먼테이션의 작동 방식, 가상 메모리, 페이징이 메모리 단편화 문제를 해결하는 방법을 다룰 것이다. 또한, x86_64 아키텍처에서 사용하는 페이지 테이블의 다층 구조도 살펴본다.

## 메모리 보호

프로그램 간 분리는 운영 체제 반드시 해야하는 일이다. 예를 들어, 웹 브라우저가 텍스트 에디터를 간섭하는 일이 없어야 한다. 이를 위해 운영 체제는 하드웨어 기능을 사용해서 프로세스가 소유한 메모리 구역을 다른 프로세스가 접근하지 못하게 한다. 하드웨어나 운영 체제 구현에 따라 프로그램 분리하는 방법이 다양하다.

예를 들어, 임베디드 시스템에 사용되는 ARM Cortex-M 프로세서는 [메모리 보호 장치](https://developer.arm.com/docs/ddi0337/e/memory-protection-unit/about-the-mpu) (Memory Protection Unit, MPU)가 있어서 메모리 구역에 다른 접근 권한(ex, 접근 불가, 읽기 전용, 읽고 쓰기 가능)을 갖도록 작은 숫자(ex, 8)를 지정할 수 있다. 메모리에 접근할 때마다 MPU가 메모리 구역 안에 있는 주소를 올바른 접근 권한으로 사용했는지 확인하고, 그렇지 않은 경우 예외를 발생시킨다. 프로세스를 전환할 때마다 구역과 접근 권한을 바꿔서 운영 체제가 각 프로세스가 자신의 메모리에 접근하도록 한다. 이런 식으로 프로세스를 서로 분리한다.

x86은 [세그먼테이션](https://ko.wikipedia.org/wiki/X86_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B6%84%ED%95%A0)과 [페이징](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95), 이 두 가지 메모리 보호 방식을 지원한다.

## 세그먼테이션 (메모리 분할)

세그먼테이션은 접근할 수 있는 메모리 양을 늘리기 위해 1978년에 도입됐다. 그 당시에 CPU는 16비트 주소만 사용할 수 있어서 접근할 수 있는 메모리 양이 64KB로 제한됐다. 64KB보다 더 많이 접근하기 위해 세그먼트 레지스터들이 추가됐고, 각 세그먼트 레지스터는 오프셋 주소를 담는다. CPU는 메모리에 접근할 때마다 오프셋을 더 해서, 1MB 크기의 메모리까지 접근이 가능했다.

CPU는 메모리 접근 방식에 따라 세그먼트 레지스터를 자동으로 선택한다. 명령어를 가져올 땐 코드 세그먼트(`CS`)를 사용하고, 스택 연산(push/pop) 시 스택 세그먼트(`SS`)를 사용한다. 다른 명령어는 데이터 세그먼트(`DS`)나 여분 세그먼트(`ES`)를 사용한다. 나중에 추가된 여분 세그먼트 레지스터인 `FS`와 `GS`는 자유롭게 사용된다.

세그먼테이션의 초창기 버전에서 오프셋이 세그먼트 레지스터에 그대로 담겨있었고 접근 제어도 실행되지 않았다. 초창기 버전은 [_보호 모드_](https://ko.wikipedia.org/wiki/%EB%B3%B4%ED%98%B8_%EB%AA%A8%EB%93%9C)가 도입되면서 변경됐다. CPU가 보호 모드에서 작동할 때, 세그먼트 디스크립터는 로컬과 글로벌 [_디스크립터 테이블_](https://en.wikipedia.org/wiki/Global_Descriptor_Table)의 인덱스를 담는다. 디스크립터 테이블은 오프셋 주소를 포함하여 세그먼트 사이즈와 접근 권한을 담는다. 각 프로세스 마다 프로세스 고유의 메모리 영역에만 접근하도록 하는 별개의 글로벌/로컬 디스크립터 테이블을 불러와서 운영 체제가 프로세스 간 분리를 할 수 있다.

실제 메모리 접근 전에 주소를 변경하는 방법을 사용하는 세그먼테이션은 현재 거의 모든 곳에서 사용 중인 _가상 메모리_ 기법을 이미 사용하고 있다.
