# 페이징 구현하기

커널에 페이징 지원을 추가한다. 커널이 물리 페이지 테이블 프레임을 접근할 수 있게 하는 다양한 기법을 살펴보고 각각의 장단점을 논의한다. 그런 다음 주소 변환 함수와 새 매핑을 생성하는 함수를 구현한다.

## 도입

페이징의 개념을 설명한 [이전 글](https://yongj.in/rust%20os/rust-os-intoduction-to-paging/)에서 페이징을 세그먼테이션과 비교하고, 페이징과 페이징 테이블의 작동방식을 설명하고, `x86_64`의 4단 페이지 테이블 설계를 소개했다. 부트로더가 이미 페이지 테이블 계층 설정을 해놓아서 커널은 이미 가상 주소를 기반으로 작동하고 있음을 알았다. 커널의 페이징 설정 덕분에 허용되지 않은 메모리 접근 시 페이지 폴트 예외가 발생해서 물리 메모리가 임의로 변경되는 일을 막을 수 있다.

이전 글은 [커널에서 페이지 테이블에 접근할 수 없다](https://yongj.in/rust%20os/rust-os-intoduction-to-paging/#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0)는 문제로 끝이 난다. 페이지 테이블은 물리 메모리에 저장되어 있고 커널은 이미 가상 주소 위에서 작동하고 있기 때문이다. 이번 글에서 이 문제를 이어서 다루고 페이지 테이블 프레임을 커널에서 접근할 수 있게 만드는 다양한 방법을 살펴본다. 각 방법의 장단점을 논의하고 커널에 사용할 방법 결정한다.

방법 구현을 위해 부트로더의 도움이 필요하다. 부트로더를 설정한 다음, 가상 주소를 물리 주소로 변환하기 위해 페이지 테이블 계층을 순회하는 함수를 구현한다. 마지막으로, 페이지 테이블에 새 매핑을 생헝하는 방법과 새 페이지 테이블을 생성하기을 위해 사용하지 않는 메모리 프레임을 찾는 방법을 배워본다.

## 페이지 테이블 접근하기

커널에서 페이지 테이블에 접근하기가 생각보다 쉽지 않다. 왜 그런지 이해하기 위해서 이전 글의 4단 페이지 테이블 예시를 살펴본다.

![4-level-page-table](https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg)

여기서 중요한 점은 각 페이지 항목이 다음 테이블의 실제 주소를 저장한다는 점이다. 이렇게 하면 주소를 변환할 필요가 없으므로 성능 저하와 무한 변환 루프를 막을 수 있다.

문제는 커널이 가상 주소 위에서 동작하므로 커널에서 실제 물리 주소에 직접 접근할 수 없다는 것이다. 예를 들어, `4KB` 주소를 접근할 때 레벨 4 페이지 테이블이 저장된 물리 주소 `4KB`가 아닌 가상 주소 `4KB`에 접근한다. 물리 주소 `4KB`에 접근하기 위해서는 물리 주소 위에 가상 주소를 매핑해서 접근해야 한다.

페이지 테이블 프레임에 접근하기 위해서는 해당 프레임에 가상 페이지를 매핑해야 한다. 프레임에 매핑을 생성해서 임의의 페이지 테이블 프레임에 접근할 수 있는 다양한 방법을 소개한다.

### 동일 매핑 (Identity Mapping)

가장 단순한 방법은 모든 페이지 테이블을 동일하게 매핑하는 것이다.

![identity-mapping](https://os.phil-opp.com/paging-implementation/identity-mapped-page-tables.svg)

이 예제에서 다양한 동일하게 매핑된 페이지 테이블을 살펴본다. 동일 매핑 방식에서 페이지 테이블의 물리 주소가 유효한 가상 주소이므로 CR3 레지스터에서 시작하는 모든 레벨의 페이지 테이블에 쉽게 접근할 수 있다.

그러나, 가상 주소 공간이 복잡해져서 크기가 큰 연속 메모리 공간을 찾기 어려워 진다. 예를 들어, 위 그림에서 [메모리 맵 파일](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%A7%B5_%ED%8C%8C%EC%9D%BC)에 사용할 1000KB 크기의 가상 메모리 구역을 생성해야 한다고 쳐본다. `1004KB`에 이미 매핑된 페이지 때문에 메모리 구역을 `28KB`에서 시작할 수 없다. 그래서 더 살펴본 다음 `1008KB` 같이 충분히 넓고 매핑되지 않은 구역을 찾아야 한다. 이는 세그먼테이션의 파편화 문제와 비슷하다.

마찬가지로, 대응되는 페이지가 아직 사용되지 않는 물리 프레임을 찾아야 하므로 새 페이지 테이블을 생성하기도 어려워진다. 예를 들어, 메모리 맵 파일에 사용하기 위해 `1008KB`에서 시작하는 1000KB 크기의 가상 메모리 구역을 예약했다고 가정해본다. 이제 `1000KB`에서 `2008KB` 사이의 물리 주소를 가진 프레임을 사용할 수 없게 된다.

### 고정 오프셋에서 매핑하기

가상 주소 공간이 복잡해지는 문제를 막기 위해 페이지 테이블 매핑에 별도의 메모리 영역을 사용할 수 있다. 페이지 테이블 프레임을 동일 매핑하는 대신에 프레임을 가상 주소 공간에서 고정 오프셋으로 매핑한다. 예를 들어 오프셋이 10TB일 수도 있다.

![map-at-fixed-offset](https://os.phil-opp.com/paging-implementation/page-tables-mapped-at-offset.svg)

페이지 테이블 매핑에만 `10TiB..(10TiB + 물리 메모리 크기)` 범위의 가상 주소를 사용해서 동일 매핑의 충돌 문제를 피할 수 있다. 이렇게 큰 가상 주소 공간을 예약하려면 가상 주소 공간이 물리 메모리 크기보다 훨씬 커야한다는 조건이 있다. `x86_64`은 256TB 크기의 주소 공간을 가지는 48비트 주소를 사용하므로 이 조건은 문제가 되지 않는다.

이 방식은 페이지 테이블을 새로 만들 때마다 매핑도 새로 만들어야 한다는 단점이 남아있다. 또한, 새 프로세스를 생성할 때 유용한 다른 주소 공간의 페이지 테이블 접근도 할 수 없다.

### 완전한 물리 메모리에 매핑하기

페이지 테이블 프레임 뿐만 아니라 완전한 물리 메모리에 매핑해서 문제를 해결할 수 있다.

![Map the Complete Physical Memory](https://os.phil-opp.com/paging-implementation/map-complete-physical-memory.svg)

이 방식을 사용하면 커널이 다른 주소 공간의 페이지 테이블 프레임을 포함한 임의의 물리 메모리에 접근할 수 있다. 예약된 가상 메모리 범위 크기는 그대로이고 매핑되지 않은 페이지만 포함되지 않는다.

이 방식은 물리 메모리의 매핑을 저장할 페이지 테이블이 추가로 필요하다는 단점이 있다. 추가 페이지 테이블은 어딘가에 저장되어 물리 메모리를 차지하는데, 이는 메모리가 작은 장치에 문제가 될 수 있다.

그러나 x86_64에서 기본 4KB 크기 페이지 대신에 2MB 크기의 대용량 페이지를 매핑에 사용할 수 있다. 대용량 페이지를 사용하면 32GB의 물리 메모리를 매핑하는데 레벨 3 테이블 1개와 레벨 2 테이블 32개 밖에 필요하지 않기 때문에 132KB만 필요하다. 또한, 대용량 페이지는 변환 색인 버퍼에 적은 수의 항목만 사용하므로 캐시 효율성이 향상된다.

### 임시 매핑

물리 메모리가 매우 작은 장치는 **페이지 테이블 프레임에 접근할 때만 일시적으로 매핑**할 수 있다. 동일 매핑된 레벨 1 테이블 한 개만 있으면 임시 매핑을 생성할 수 있다.

![Temporary Mapping](https://os.phil-opp.com/paging-implementation/temporarily-mapped-page-tables.svg)

그림 속 레벨 1 테이블은 가상 주소 공간의 처음 2MB만 제어한다. CR3 레지스터와 뒤따르는 레벨 4, 3, 2 페이지 테이블의 0번 항목에서 도달할 수 있기 때문이다. 인덱스 8번 항목은 `32KB` 주소의 가상 페이지를 `32KB` 주소의 물리 프레임에 매핑해서 레벨 1 테이블 자체를 동일 매핑한다. 그림에서 `32KB`에서 수평 화살표로 동일 매핑된 것을 확인할 수 있다.

커널은 동일 매핑된 레벨 1 테이블을 사용해서 최대 511개의 임시 매핑을 만들 수 있다 (512 - 동일 매핑에 필요한 항목 수). 위 예에서 커널은 두 가지 임시 매핑을 생성했다.

- 레벨 1 테이블의 0번째 항목을 `24KB` 주소의 프레임에 매핑함으로써, `0KB` 주소의 가상 페이지를 레벨 2 페이지 테이블의 물리 프레임에 임시 매핑해서 점선 화살표로 표시했다.
- 레벨 1 테이블의 9번째 항목을 `4KB` 주소의 프레임에 매핑함으로써, `36KB` 주소의 가상 페이지를 레벨 4 페이지 테이블의 물리 프레임에 임시 매핑해서 점선 화살표로 표시했다.

이제 커널은 `0KB` 페이지에 쓰기를 하면 레벨 2 페이지 테이블에 접근할 수 있고 `36KB` 페이지에 쓰기를 하면 레벨 4 페이지 테이블에 접근할 수 있다.

임시 매핑을 사용해서 임의의 페이지 테이블 프레임에 접근하는 과정은 다음과 같다.

- 동일 매핑된 레벨 1 테이블에서 빈 항목을 찾는다.
- 찾은 빈 항목을 접근하려는 페이지의 물리 프레임에 매핑한다.
- 항목에 매핑된 가상 페이지를 통해 타깃 프레임에 접근한다.
- 항목을 미사용으로 다시 설정해서 임시 매핑을 제거한다.

이 방식은 매핑 생성에 동일한 512개의 가상 페이지를 재사용하므로 물리 메모리 4KB만 사용한다. 단점은 새 매핑 생성 시 여러 테이블 레벨을 수정하는데 위 과정을 여러 번 반복하는 것이 다소 번거롭다는 점이다.

