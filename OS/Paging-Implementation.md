# 페이징 구현하기

커널에 페이징 지원을 추가한다. 커널이 물리 페이지 테이블 프레임을 접근할 수 있게 하는 다양한 기법을 살펴보고 각각의 장단점을 논의한다. 그런 다음 주소 변환 함수와 새 매핑을 생성하는 함수를 구현한다.

## 도입

페이징의 개념을 설명한 [이전 글](https://yongj.in/rust%20os/rust-os-intoduction-to-paging/)에서 페이징을 세그먼테이션과 비교하고, 페이징과 페이징 테이블의 작동방식을 설명하고, `x86_64`의 4단 페이지 테이블 설계를 소개했다. 부트로더가 이미 페이지 테이블 계층 설정을 해놓아서 커널은 이미 가상 주소를 기반으로 작동하고 있음을 알았다. 커널의 페이징 설정 덕분에 허용되지 않은 메모리 접근 시 페이지 폴트 예외가 발생해서 물리 메모리가 임의로 변경되는 일을 막을 수 있다.

이전 글은 [커널에서 페이지 테이블에 접근할 수 없다](https://yongj.in/rust%20os/rust-os-intoduction-to-paging/#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0)는 문제로 끝이 난다. 페이지 테이블은 물리 메모리에 저장되어 있고 커널은 이미 가상 주소 위에서 작동하고 있기 때문이다. 이번 글에서 이 문제를 이어서 다루고 페이지 테이블 프레임을 커널에서 접근할 수 있게 만드는 다양한 방법을 살펴본다. 각 방법의 장단점을 논의하고 커널에 사용할 방법 결정한다.

방법 구현을 위해 부트로더의 도움이 필요하다. 부트로더를 설정한 다음, 가상 주소를 물리 주소로 변환하기 위해 페이지 테이블 계층을 순회하는 함수를 구현한다. 마지막으로, 페이지 테이블에 새 매핑을 생헝하는 방법과 새 페이지 테이블을 생성하기을 위해 사용하지 않는 메모리 프레임을 찾는 방법을 배워본다.








