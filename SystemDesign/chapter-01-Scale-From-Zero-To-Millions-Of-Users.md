# [대규모 시스템 설계 기초] 1장 사용자 수에 따른 규모 확장성

## 단일 서버

- 웹, 앱, DB, 캐시 모두 서버 한 대에서 실행된다.

### 사용자 요청 처리 흐름

1. 사용자는 도메인 이름으로 웹사이트에 접속.
2. DNS가 도메인 이름을 IP 주소로 변환함.
3. 해당 IP 주소로 HTTP 요청 전달
4. 웹 서버가 HTML이나 JSON 응답 반환

## 데이터베이스

- 웹/모바일 트래픽 처리 서버와 데이터베이스 서버로 분리해서 각각 독립적으로 확장해 나간다.

### 관계형 DB

- 자료를 테이블, 열, 칼럼으로 표현
- SQL로 여러 테이블의 데이터를 조인해서 합침

### NoSQL

1. 키-값 저장소
2. 그래프 저장소
3. 칼럼 저장소
4. 문서 저장소

#### NoSQL을 사용하는 경우

- 낮은 레이턴시 필요
- 비정형 데이터
- 데이터 직렬화/역직렬화 기능만 필요
- 데이터 양이 많음

## 스케일 업 VS 스케일 아웃

### 스케일 업

- 수직적 규모 확장
- 서버 성능 높이기

### 스케일 아웃

- 수평적 규모 확장
- 서버 수 늘리기

### 스케일 업 단점

- 서버 하나에 추가할 수 있는 CPU와 메모리는 제한적
- 장애 자동 복구나 다중화 방안 X
  - 서버 장애 시 웹사이트/앱 중단

## 로드밸런서

- 웹 서버에 트래픽 분산
- 사용자는 로드밸런서의 공개 IP 주소로 접속
- 웹 서버는 사설 IP 주소 로드밸런서와 연결됨
- 자동 복구와 가용성 보장
  - 서버 하나가 다운되면 다른 서버에 트래픽 전송. 또는 새 서버 추가

## DB 다중화

- DB 서버 간 마스터-슬레이브 관계 설정
- 쓰기 연산은 마스터만
- 슬레이브는 마스터의 사본을 전달받고 읽기 연산 지원
- 대부분의 앱은 읽기 연산이 쓰기 연산보다 많이 일어남

### DB 다중화의 장점

- 성능: 쿼리 병렬성 증가로 성능 향상
- 안정성: DB 일부가 파괴돼도 데이터 보존. 다른 지역에 다중화 가능
- 가용성: DB 서버가 다운돼도 다른 서버의 데이터 사용 가능

### DB 서버 다운 시

#### 슬레이브 다운 시

- 슬레이브 한 대뿐이면, 읽기 연산은 마스터 DB로 감
- 슬레이브가 여러 대면, 읽기 연산은 다른 슬레이브로 감

#### 마스터 다운 시

- 슬레이브가 하나면, 해당 슬레이브가 새 마스터가 되고 새 슬레이브가 추가됨
- 슬레이브 DB의 데이터가 최신이 아닐 경우 복구 스크립트 실행

### DB 수직적 확장

- DB 서버 성능 높이기
- 단일 장애 지점 위험성
- 고성능일수록 가격이 올라감

### DB 수평적 확장

- 샤딩
- DB를 샤드라는 단위로 분할
- 모든 샤드는 스키마는 같지만, 데이터의 중복은 없음
- DB가 4개면 `id % 4`같은 해시 함수로 데이터가 보관될 샤드 정함

### 샤딩 관련 문제

#### 데이터 재 샤딩

- 데이터가 너무 많아서 하나의 샤드로 감당하기 어려울 때
- 샤드 간 데이터 분포가 균등하지 않을 경우 (샤드 소진)
- -> 샤드 키를 계산하는 함수를 변경후고 데이터를 재배치
- -> 또는 안정 해시 기법 사용

#### 유명인사 문제

- 핫스팟 키 문제
- 특정 샤드에 질의가 집중되어 서버에 과부하 걸리는 문제
- Katy Perry, Justin Bieber, Lady Gaga가 전부 같은 샤드에 저장되는 경우

#### 조인과 비정규화

- 여러 샤드에 걸친 데이터를 조인하기는 힘듦
- 데이터베이스를 비정규화해서 하나의 테이블에서 쿼리를 할 수 있게 하는 방법이 있음

## 캐시

- 연산이 비싸거나 자주 참조되는 데이터를 메모리에 두고 다음 요청을 빠르게 처리하는 저장소

### 캐시 사용 시 유의점

- 데이터 갱신보다 참조가 많이 일어나는 경우 도입
- 영구 보관이 필요한 데이터는 캐시보다 지속 저장소에 저장
- 만료 정책
  - 만료 정책이 없으면 데이터는 캐시에 계속 남음
  - 만료 정책이 너무 짧으면 DB를 너무 자주 읽음
  - 만료 정책이 너무 길면 데이터가 원본과 차이가 나게 됨
- 데이터 원본과 캐시 내 사본 일관성 유지. 여러 캐시 저장소 간 일관성
- 캐시 서버가 한 대만 있으면 단일 장애 지점이 될 수 있음
- 캐시 메모리 크기
  - 너무 작으면 데이터가 너무 자주 밀려나서 성능 하락
  - 캐시 크기는 넉넉하게 잡으면 좋다.
- 데이터 방출 정책
  - LRU - 가장 오래된 것 방출
  - LFU - 가장 적게 사용된 것 방출
  - FIFO - 가장 먼저 들어온 것 방출

## CDN

- 정적 콘텐츠를 지리적으로 분산된 서버에서 제공함
- 사용자에게 가장 가까운 CDN 서버에서 정적 콘텐츠를 전달함

### CDN 사용 시 고려 사항

- 데이터 전송 양에 따라 요금이 부과됨. 자주 사용하지 않는 콘텐츠는 빼기
- 만료 시점 설정. 콘텐츠의 신선도 유지
- CDN 장애 시 대처
  - CDN이 응답하지 않을 경우, 감지해서 원본 서버에서 직접 콘텐츠 가져오도록 구성
- 콘텐츠 무효화
  - CDN API 이용
  - 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝(versioning) 설정

## 무상태 웹 계층

- 웹 계층을 수평적으로 확장하기 위해 상태 정보(세션 등)를 웹 계층에서 제거해야 함
- RDBMS나 NoSQL에 상태 정보 저장
- 보통 확장이 간편한 NoSQL 사용

## 지리적 라우팅

- 전 세계에서 사용되는 서비스는 여러 곳에 데이터 센터를 둬야 함
- GeoDNS는 사용자의 위치에 따라 가장 가까운 서버의 IP 주소를 반환함

### 다중 데이터 센터의 기술적 난제

- 트래픽 우회: GeoDNS로 가까운 데이터 센터로 트래픽 전송
- 데이터 동기화: 데이터를 여러 데이터 센터에 걸쳐 다중화
- 테스트: 여러 위치에서 테스트하기
- 배포: 자동 배포로 모든 데이터 센터에 동일한 서비스 설치하기

## 메시지 큐

- 시스템을 분리하고 독립적으로 확장할 때 유용
- 메시지의 무손실성 보장하며 비동기 통신을 지원
- 오래 걸리는 프로세스를 비동기적으로 처리할 때도 사용

## 로그, 메트릭, 자동화

### 로그

- 시스템의 오류를 쉽게 찾을 수 있다.
- 로그를 하나로 모아주는 서비스를 사용하는 게 좋다.

### 메트릭

- 사업 현황에 유용한 정보를 제공하고, 시스템의 상태를 파악할 수 있다.
- 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O
- 종합 메트릭: DB나 캐시 성능
- 핵심 비즈니스 메트릭: DAU, 수익, 재방문 등

### 자동화

- 시스템이 복잡해지면 생산성을 높이기 위해 자동화 도구 사용이 필요
- CI: 코드 검증 절차 자동화

## 마무리

- 시스템의 규모 확장은 지속적이고 반복적인 과정
- 시스템을 최적화하고 더 작은 단위의 서비스로 나눠야 할 수도 있음

### 정리

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구를 활용할 것
